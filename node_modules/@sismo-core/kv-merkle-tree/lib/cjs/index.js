'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var ethers = require('ethers');

var KV = /** @class */ (function () {
    function KV() {
        this.store = {};
    }
    KV.prototype.put = function (key, value) {
        this.store[key] = value;
    };
    KV.prototype.patch = function (key, value) {
        this.store[key] = tslib.__assign(tslib.__assign({}, this.store[key]), value);
    };
    KV.prototype.get = function (key) {
        return this.store[key];
    };
    KV.prototype.toJson = function () {
        return JSON.stringify(this.store);
    };
    KV.prototype.toDict = function () {
        return this.store;
    };
    KV.prototype.importJson = function (json) {
        this.store = json;
    };
    KV.prototype.isEmpty = function () {
        return Object.keys(this.store).length === 0;
    };
    return KV;
}());

var ERROR_NO_HASH_FUNCTION = "Must define an hash function.";
var HASH_NULL_DICT = {
    "0x00": "0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864",
    "0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864": "0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1",
    "0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1": "0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238",
    "0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238": "0x07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a",
    "0x07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a": "0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55",
    "0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55": "0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78",
    "0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78": "0x078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d",
    "0x078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d": "0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61",
    "0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61": "0x0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747",
    "0x0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747": "0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2",
    "0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2": "0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636",
    "0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636": "0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a",
    "0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a": "0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0",
    "0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0": "0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c",
    "0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c": "0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92",
    "0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92": "0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323",
    "0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323": "0x2e8186e558698ec1c67af9c14d463ffc470043c9c2988b954d75dd643f36b992",
    "0x2e8186e558698ec1c67af9c14d463ffc470043c9c2988b954d75dd643f36b992": "0x0f57c5571e9a4eab49e2c8cf050dae948aef6ead647392273546249d1c1ff10f",
    "0x0f57c5571e9a4eab49e2c8cf050dae948aef6ead647392273546249d1c1ff10f": "0x1830ee67b5fb554ad5f63d4388800e1cfe78e310697d46e43c9ce36134f72cca"
};
var KVMerkleTree = /** @class */ (function () {
    /**
     * @param data Data used to generate your Merkle tree
     * @param hashFunction Hash function used to generate your Merkle tree
     * @param forceHeight Force the number of levels in your Merkle tree
     * @param hashLeaves Define if your leaf will be hashed or not
     * @param jsonMerkleTree Used only by fromJson function
     * @param leaves Used only by fromLeaves function
     */
    function KVMerkleTree(data, hashFunction, forceHeight, hashLeaves, jsonMerkleTree, leaves) {
        if (hashFunction === void 0) { hashFunction = null; }
        if (forceHeight === void 0) { forceHeight = null; }
        if (hashLeaves === void 0) { hashLeaves = true; }
        if (jsonMerkleTree === void 0) { jsonMerkleTree = null; }
        if (leaves === void 0) { leaves = null; }
        this.root = null;
        this.hashFunction = null;
        this.height = 0;
        this.forceHeight = null;
        this.hashLeaves = true;
        if (forceHeight)
            this.forceHeight = forceHeight;
        this.hashFunction = hashFunction;
        this.tree = new KV();
        this.pointers = new KV();
        this.hashLeaves = hashLeaves;
        if (data) {
            if (!this.hashFunction)
                throw new Error(ERROR_NO_HASH_FUNCTION);
            this.initFromData(data);
        }
        else if (jsonMerkleTree) {
            this.tree.importJson(jsonMerkleTree.tree);
            if (jsonMerkleTree.pointers)
                this.pointers.importJson(jsonMerkleTree.pointers);
            this.height = jsonMerkleTree.height;
            this.root = jsonMerkleTree.root;
        }
        else if (leaves) {
            if (!this.hashFunction)
                throw new Error(ERROR_NO_HASH_FUNCTION);
            this.initFromLeaves(leaves);
        }
    }
    KVMerkleTree.prototype.initFromLeaves = function (leaves) {
        if (!this.hashFunction)
            throw new Error(ERROR_NO_HASH_FUNCTION);
        if (this.hashLeaves) {
            var leavesHashed = [];
            for (var _i = 0, leaves_1 = leaves; _i < leaves_1.length; _i++) {
                var leaf = leaves_1[_i];
                leavesHashed.push(this.hashFunction([ethers.BigNumber.from(leaf)]).toHexString());
            }
            this.createNodes(this.fillNodesWithPowerOf2Length(leavesHashed));
            return;
        }
        this.createNodes(this.fillNodesWithPowerOf2Length(leaves));
    };
    KVMerkleTree.prototype.initFromData = function (data) {
        if (!this.hashFunction)
            throw new Error(ERROR_NO_HASH_FUNCTION);
        var leaves = [];
        for (var key in data) {
            var value = ethers.BigNumber.from(data[key]);
            var leaf = void 0;
            if (this.hashLeaves) {
                leaf = this.hashFunction([ethers.BigNumber.from(key), value]).toHexString();
            }
            else {
                leaf = key.concat(value.toString());
            }
            this.pointers.put(key.toLowerCase(), {
                leaf: leaf,
                value: value.toHexString()
            });
            leaves.push(leaf);
        }
        this.createNodes(this.fillNodesWithPowerOf2Length(leaves));
    };
    KVMerkleTree.prototype.createNodes = function (nodeValues) {
        if (!this.hashFunction)
            throw new Error(ERROR_NO_HASH_FUNCTION);
        if (nodeValues.length == 1) {
            this.root = nodeValues[0];
            return [];
        }
        var parentNodeValues = [];
        for (var i = 0; i < nodeValues.length; i += 2) {
            var leftNodeValue = nodeValues[i];
            var rightNodeValue = nodeValues[i + 1];
            var parentNodeValue = void 0;
            if (leftNodeValue == rightNodeValue && HASH_NULL_DICT[leftNodeValue]) {
                parentNodeValue = HASH_NULL_DICT[leftNodeValue];
            }
            else {
                parentNodeValue = this.hashFunction([leftNodeValue, rightNodeValue]).toHexString();
            }
            this.tree.patch(leftNodeValue, { p: parentNodeValue });
            this.tree.patch(rightNodeValue, { p: parentNodeValue });
            this.tree.put(parentNodeValue, {
                l: leftNodeValue,
                r: rightNodeValue
            });
            parentNodeValues.push(parentNodeValue);
        }
        this.height += 1;
        return this.createNodes(parentNodeValues);
    };
    KVMerkleTree.prototype.fillNodesWithPowerOf2Length = function (leaves) {
        var next = 0;
        if (this.forceHeight) {
            next = Math.pow(2, this.forceHeight);
        }
        else {
            next = Math.pow(2, Math.ceil(Math.log(leaves.length) / Math.log(2)));
        }
        return tslib.__spreadArray(tslib.__spreadArray([], leaves, true), new Array(next - leaves.length).fill(ethers.BigNumber.from(0).toHexString()), true);
    };
    KVMerkleTree.prototype.getMerklePathFromKey = function (key) {
        if (this.pointers.isEmpty())
            throw new Error("Your tree is generate from leaves. No key / values available. Please use getMerklePathFromLeaf instead.");
        var node = this.pointers.get(key.toLowerCase());
        if (!node)
            throw new Error("Key not found in the Merkle tree");
        return this.getMerklePathFromLeaf(node.leaf);
    };
    KVMerkleTree.prototype.getMerklePathFromLeaf = function (leaf) {
        var merklePath = {
            elements: new Array(),
            indices: new Array(),
        };
        var currentNodeValue = leaf;
        var currentNode = this.tree.get(currentNodeValue);
        if (!currentNode)
            throw new Error("Leaf not found in the Merkle tree");
        while (currentNode.p) {
            var parentValue = currentNode.p;
            var parentNode = this.tree.get(parentValue);
            if (parentNode.l === currentNodeValue) { // If the left child of the parent is the currentNode we register the right child in the merklePath
                merklePath.elements.push(ethers.BigNumber.from(parentNode.r));
                merklePath.indices.push(0);
            }
            else if (parentNode.r === currentNodeValue) { // Else we register the left child
                merklePath.elements.push(ethers.BigNumber.from(parentNode.l));
                merklePath.indices.push(1);
            }
            currentNodeValue = parentValue;
            currentNode = parentNode;
        }
        return merklePath;
    };
    KVMerkleTree.prototype.verifyMerklePath = function (merklePath, leaf) {
        if (!this.hashFunction)
            throw new Error(ERROR_NO_HASH_FUNCTION);
        var currentNodeValue = leaf;
        var currentNode = this.tree.get(currentNodeValue);
        if (!currentNode)
            throw new Error("Leaf not found in the Merkle tree");
        for (var i = 0; i < merklePath.indices.length; i++) {
            if (merklePath.indices[i] == 0) {
                currentNodeValue = this.hashFunction([currentNodeValue, merklePath.elements[i].toHexString()]).toHexString();
            }
            else {
                currentNodeValue = this.hashFunction([merklePath.elements[i].toHexString(), currentNodeValue]).toHexString();
            }
        }
        return currentNodeValue == this.getRoot().toHexString();
    };
    KVMerkleTree.prototype.getValue = function (key) {
        if (this.pointers.isEmpty())
            throw new Error("Your tree is generate from leaves. No key / values available.");
        var node = this.pointers.get(key.toLowerCase());
        if (!node)
            throw new Error("Key not found in the Merkle tree");
        return ethers.BigNumber.from(node.value);
    };
    KVMerkleTree.prototype.getLeaf = function (key) {
        if (this.pointers.isEmpty())
            throw new Error("Your tree is generate from leaves. No key / values available.");
        var node = this.pointers.get(key.toLowerCase());
        if (!node)
            throw new Error("Key not found in the Merkle tree");
        return ethers.BigNumber.from(node.leaf);
    };
    KVMerkleTree.prototype.getPosition = function (key) {
        if (this.pointers.isEmpty())
            throw new Error("Your tree is generate from leaves. No key / values available.");
        var MerklePath = this.getMerklePathFromKey(key);
        var positionBinaryArray = MerklePath.indices.reverse();
        var positionBinaryString = positionBinaryArray.join("");
        var positionNumber = parseInt(positionBinaryString, 2);
        return positionNumber;
    };
    KVMerkleTree.prototype.getRoot = function () {
        return ethers.BigNumber.from(this.root);
    };
    KVMerkleTree.prototype.getHeight = function () {
        return this.height;
    };
    KVMerkleTree.fromLeaves = function (leaves, hashFunction, forceHeight, hashLeaves) {
        if (forceHeight === void 0) { forceHeight = null; }
        if (hashLeaves === void 0) { hashLeaves = false; }
        return new KVMerkleTree(null, hashFunction, forceHeight, hashLeaves, null, leaves);
    };
    KVMerkleTree.fromJson = function (jsonMerkleTree) {
        return new KVMerkleTree(null, null, null, true, jsonMerkleTree);
    };
    KVMerkleTree.prototype.toJson = function () {
        if (!this.root)
            throw new Error("The Merkle tree is not yet initialized.");
        var json = {
            root: this.root,
            height: this.height,
            tree: this.tree.store
        };
        if (!this.pointers.isEmpty())
            json["pointers"] = this.pointers.store;
        return json;
    };
    return KVMerkleTree;
}());

exports.KVMerkleTree = KVMerkleTree;
//# sourceMappingURL=index.js.map
